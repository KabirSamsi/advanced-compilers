@print_through(arr: ptr<int>, size: int) {
  one: int = const 1;
  i: int = const 0;
.loop:
  cond: bool = lt i size;
  br cond .printmore .done;
.printmore:
  idx: ptr<int> = ptradd arr i;
  elem: int = load idx;
  print elem;
.loopcheck:
  i: int = add i one;
  jmp .loop;
.done:
  print;
  ret;
}
@push(stack: ptr<int>, newnode: int, size: int): ptr<int> {
  zero: int = const 0;
  empty: bool = eq size zero;
  br empty .push_empty .push_nonempty;
.push_empty:
  store stack newnode;
  ret stack;
.push_nonempty:
  one: int = const 1;
  newsize: int = add size one;
  result: ptr<int> = alloc newsize;
  i: int = const 0;
  write_idx: ptr<int> = ptradd result i;
  store write_idx newnode;
  read_idx: ptr<int> = ptradd stack i;
  i: int = add i one;
.copyloop:
  cond: bool = lt i newsize;
  br cond .copy .done;
.copy:
  top: int = load read_idx;
  write_idx: ptr<int> = ptradd result i;
  store write_idx top;
  read_idx: ptr<int> = ptradd stack i;
.loop_end:
  i: int = add i one;
  jmp .copyloop;
.done:
  free stack;
  ret result;
}
@pop(stack: ptr<int>, size: int): ptr<int> {
  one: int = const 1;
  has_one: bool = eq size one;
  br has_one .pop_one .pop_multiple;
.pop_one:
  negone: int = const -1;
  store stack negone;
  ret stack;
.pop_multiple:
  newsize: int = sub size one;
  result: ptr<int> = alloc newsize;
  i: int = const 1;
.copyloop:
  cond: bool = lt i size;
  br cond .copy .done;
.copy:
  read_idx: ptr<int> = ptradd stack i;
  top: int = load read_idx;
  write_pos: int = sub i one;
  write_idx: ptr<int> = ptradd result write_pos;
  store write_idx top;
.loop_end:
  i: int = add i one;
  jmp .copyloop;
.done:
  free stack;
  ret result;
}
@first_unvisited(visited: ptr<int>, n: int): int {
  i: int = const 0;
  zero: int = const 0;
  one: int = const 1;
.loop:
  offset: ptr<int> = ptradd visited i;
  loaded: int = load offset;
  bounds: bool = eq i n;
  found: bool = eq loaded zero;
  cond: bool = or bounds found;
  br cond .terminate .continue;
.continue:
  i: int = add i one;
  jmp .loop;
.terminate:
  ret i;
}
@dfs(graph: ptr<int>, n: int): int {
  zero: int = const 0;
  one: int = const 1;
  visited: ptr<int> = alloc n;
  i: int = const 0;
.populate_visited:
  cond: bool = lt i n;
  br cond .keep_looping .rest;
.keep_looping:
  offset: ptr<int> = ptradd visited i;
  store offset zero;
  i: int = add i one;
  jmp .populate_visited;
.rest:
  visited_count: int = const 0;
  components: int = const 0;
.component_loop:
  cond: bool = lt visited_count n;
  br cond .dfs_init .end;
.dfs_init:
  next_node: int = call @first_unvisited visited n;
  component_cluster: ptr<int> = alloc one;
  store component_cluster next_node;
  cluster_size: int = const 1;
  visited_offset: ptr<int> = ptradd visited next_node;
  store visited_offset one;
  stack: ptr<int> = alloc one;
  stack_size: int = const 1;
  store stack next_node;
  visited_count: int = add visited_count one;
.dfs_loop:
  cond: bool = gt stack_size zero;
  br cond .trav_loop .terminate;
.trav_loop:
  top: int = load stack;
  stack: ptr<int> = call @pop stack stack_size;
  stack_size: int = sub stack_size one;
  i: int = const 0;
.neighbor_loop:
  iter_cond: bool = lt i n;
  br iter_cond .iter .break;
.iter:
  row_idx: int = mul top n;
  cell_idx: int = add row_idx i;
  cell: ptr<int> = ptradd graph cell_idx;
  cell_data: int = load cell;
  visited_cell: ptr<int> = ptradd visited i;
  visited_data: int = load visited_cell;
  is_neighbor: bool = eq cell_data one;
  not_visited: bool = eq visited_data zero;
  push_cond: bool = and is_neighbor not_visited;
  br push_cond .push_stack .no_push;
.push_stack:
  stack: ptr<int> = call @push stack i stack_size;
  stack_size: int = add stack_size one;
  component_cluster: ptr<int> = call @push component_cluster i cluster_size;
  cluster_size: int = add cluster_size one;
  store visited_cell one;
  visited_count: int = add visited_count one;
.no_push:
  i: int = add i one;
  jmp .neighbor_loop;
.break:
  jmp .dfs_loop;
.terminate:
  components: int = add components one;
  free stack;
  call @print_through component_cluster cluster_size;
  free component_cluster;
  jmp .component_loop;
.end:
  free visited;
  ret components;
}
@insert_edge(graph: ptr<int>, from: int, to: int, size: int) {
  one: int = const 1;
  offset_count: int = mul from size;
  offset_count: int = add offset_count to;
  offset: ptr<int> = ptradd graph offset_count;
  store offset one;
  offset_count: int = mul to size;
  offset_count: int = add offset_count from;
  offset: ptr<int> = ptradd graph offset_count;
  store offset one;
}
@main(nodes: int) {
  dim: int = mul nodes nodes;
  adj: ptr<int> = alloc dim;
  zero: int = const 0;
  one: int = const 1;
  two: int = const 2;
  three: int = const 3;
  four: int = const 4;
  five: int = const 5;
  six: int = const 6;
  seven: int = const 7;
  i: int = const 0;
.init_loop:
  cond: bool = lt i dim;
  br cond .continue .fill_edges;
.continue:
  offset: ptr<int> = ptradd adj i;
  store offset zero;
  i: int = add i one;
  jmp .init_loop;
.fill_edges:
  call @insert_edge adj zero five nodes;
  call @insert_edge adj one two nodes;
  call @insert_edge adj two three nodes;
  call @insert_edge adj one four nodes;
  call @insert_edge adj two four nodes;
  call @insert_edge adj six seven nodes;
.compute_components:
  components: int = call @dfs adj nodes;
  free adj;
  print components;
}
